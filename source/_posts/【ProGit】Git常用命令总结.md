---
title: 【Pro Git】Git常用命令总结
tags: Git
keywords: Git
description: 根据《Pro Git 中文版（第二版）》对Git命令进行整理
excerpt: 根据《Pro Git 中文版（第二版）》对Git命令进行整理
abbrlink: cc1c6456
date: 2022-11-05 13:58:22
index_img: ../images/封面图/progit.jpg
---

### git config 查看配置信息

查看所有配置信息：

```shell
git config --list
```

查看某一条配置信息：

```shell
git config user.name
```

修改某一条配置信息：

```shell
git config user.name <value>
```

**注**：加 --global 参数后，可以查看或配置全局信息。之后该账户下面每个Git仓库都会使用该配置。

### git init 初始化Git

进入需要Git进行管理的根目录下，然后：

```shell
git init
```

### git clone 克隆远程仓库到本地

```shell
git clone <地址>
```

地址可以是HTTP/HTTPS协议，也可以是Git协议。

使用该命令后，默认将该地址设置为远程仓库并赋予别名origin。

如果想重新起一个名字而不是使用默认的origin，可以使用 -o 参数：

```shell
git clone -o <远程仓库别名>
```

### git log 查看提交记录

查看全部提交记录：
```shell
git log
```

使用 --graph 参数可以用简易图形方式呈现提交记录：

```shell
git log --graph
```

### git status 查看当前文件状态

> Git中有三种**文件状态**：已提交（committed）、已修改（modified）和已暂存（staged）。已提交指的是数据已经被保存到Git数据库中。已修改指的是文件修改过但是还没保存到数据库。已暂存指的是对已修改的文件进行了记录，下次提交这些记录会生效。

查看详细的文件状态：

```shell
git status
```

使用 -s 参数，查看简略的文件状态：

```shell
git status -s
```

文件前面的字母表示的含义：

* A：首次添加到暂存区。
* M：出现在左边表示已修改并加入到暂存区，出现在右边表示已修改但尚未加入到暂存区，左右都出现表示修改后并加入到暂存区并再次修改但未加入暂存区。
* D：从暂存区中删除。
* ?：尚未跟踪过，也就是从来都没加入到暂存区过。

### git add 添加文件到下一次提交中

可以用于对新文件的跟踪，也可以用于对修改后的文件进行暂存：

```shell
git add <文件名>
```

暂存所有文件：

```shell
git add .
```

### git diff 查看未暂存或已暂存的修改

查看未暂存的修改，也就是本地和上一次add之间的区别：

```shell
git diff
```

查看已暂存的修改，也就上一次add和上一次commit之间的区别：

```shell
git diff --cached
# 或
git diff --staged
```

### git commit 提交更新

直接使用 git commit 会启动编辑器来填写提交信息：

```shell
git commit
```

在命令同一行填写提交信息：

```shell
git commit -m "提交信息"
```

忽略将文件添加到暂存区（git add）的过程，让文件从已修改状态直接到已提交状态：

```shell
git commit -a -m "提交信息"
```

**注**：这个 -a 参数只适用于已被跟踪过的文件，如果文件没有被跟踪过，-a 参数无法生效。

### git show 查看对象信息

不加任何参数时，输查看最近一次提交的信息：

```shell
git show
```

查看各种对象（提交记录、分支、标签等等）的信息：

```shell
git show <对象>
```

### git commit --amend 撤销提交

撤销上一次提交并进行一次新的提交：

```shell
git commit --amend -m "提交信息"
```

这条指令会撤销上一次提交，并且按照**当前**暂存区中的内容进行一次新的提交。

### git reset HEAD <文件名> 撤销暂存

如果暂存文件（git add）后反悔了，可以使用该命令将文件取消暂存（从已暂存退回已修改）：

```shell
git reset HEAD <文件名>
```

### git checkout -- <文件名> 撤销修改

把已修改（但是没有暂存）的文件撤回到上一次暂存或者提交时的样子：

```shell
git checkout -- <文件名>
```

**注**：这是一个<span style="color:red">危险</span>的指令，没有暂存的修改撤销之后无法恢复。

### git rm 移除文件

> **该命令行为存疑**，尽量不使用该命令。

把文件从Git仓库或暂存区中移除，并从工作区中移除：

```shell
git rm <文件>
```

使用 -f 命令强制删除：

```shell
git rm -f <文件>
```

使用 -r 命令删除文件夹：

```shell
git rm -r <文件夹>
```

如果想把文件从Git仓库或暂存区中移除但是仍然保留在工作目录中，可以使用 --cache 参数：

```shell
git rm --cache <文件名>
```

### git mv 重命名

重命名文件：

```shell
git mv <旧文件名> <新文件名>
```

### git remote 查看远程仓库

查看**所有**远程仓库，只显示别名：

```shell
git remote
```

**注**：对于远程仓库克隆下来的项目，这个远程仓库默认的别名是 origin。

使用 -v 参数显示**所有**远程仓库的详细信息：

```shell
git remote -v
```

查看**某个**远程仓库的详细信息：

```shell
git remote show <别名>
```

查看远程仓库中分支、标签等引用列表：

```shell
git ls-remote <别名>
```

添加远程仓库并设置别名：

```shell
git remote add <别名> <地址>
```

修改远程仓库的别名：

```shell
git remote rename <旧别名> <新别名>
```

修改远程仓库地址：

```shell
git remote set-url <别名> <新地址>
```

删除某个远程仓库：

```shell
git remote remove <别名>
```

### git fetch 从远程仓库中抓取最新数据

从远程仓库（默认是origin）中抓取最新版本：

```shell
git fetch <远程仓库别名>
```

`git fetch` 命令会将**数据**拉取到本地仓库 ，但是它并**不会**自动合并或修改当前的工作。 当准备好时，必须**手动**将其合并入当前工作（将远程分支上的数据merge到当前的分支）。

上面的命令会抓取远程仓库中所有分支的最新数据，并和本地同名的分支进行比对。

如果想只抓取某个分支的最近数据，那么需要：

```shell
git fetch <远程仓库别名> <远程仓库分支名>
```

>当 `git fetch` 命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。 它只会获取数据然后让你自己合并。 然而，有一个命令叫作 `git pull` 在大多数情况下它的含义是一个 `git fetch` 紧接着一个 `git merge` 命令。 如果有一个像之前章节中演示的设置好的跟踪分支，不管它是显式地设置还是通过 `clone` 或 `checkout` 命令为你创建的，`git pull` 都会查找当前分支所跟踪的服务器与分支，从服务器上抓取数据然后尝试合并入那个远程分支。
>
>由于 `git pull` 的魔法经常令人困惑所以通常单独显式地使用 `fetch` 与 `merge` 命令会更好一些。

### git pull 从远程仓库中抓取最新数据并更新本地

从远程仓库（默认是origin）中抓取最新版本，并尝试合并到同名分支（可能出现冲突）：

```shell
git pull <远程仓库别名>
```

> 如果你有一个分支设置为跟踪一个远程分支，可以使用 `git pull` 命令来自动的抓取然后合并远程分支到当前分支。 这对你来说可能是一个更简单或更舒服的工作流程；默认情况下，`git clone` 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或不管是什么名字的默认分支）。 运行 `git pull` 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。

如果只想抓取某个分支上最新的数据并合并到同名的本地分支：

```shell
git pull <远程仓库别名> <远程仓库分支名>
```

### git push 推送到远程仓库

将某分支的内容推送到远程仓库：

```shell
git push <远程仓库别名> <本地分支名>:<远程分支名>
# 当本地目前分支和想要推送的远程分支名相同时，可以简写：
git push <远程仓库别名> <分支名>
```

> 只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先将他们的工作**拉取**下来并将其**合并**进你的工作后才能推送。

使用 -u 参数之后，下次再推动到这个远程仓库和分支时可以省略仓库别名和分支名：

```shell
git push -u <远程仓库名> <远程分支名>
```

### git tag 标签

列出所有标签：

```shell
git tag
```

> Git可以给某一次的提交打上标签，以示重要。Git 使用两种主要类型的标签：轻量标签（lightweight）与附注标签（annotated）。一个**轻量标签**很像一个不会改变的分支 - 它只是一个特定提交的引用。然而，**附注标签**是存储在 Git 数据库中的一个完整对象。 它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用 GNU Privacy Guard （GPG）签名与验证。 通常建议创建附注标签，这样你可以拥有以上所有信息；但是如果你只是想用一个临时的标签，或者因为某些原因不想要保存那些信息，轻量标签也是可用的。

创建一个**轻量标签**，不需要任何参数：

```shell
git tag <标签名>
```

查看标签信息以及对应的提交信息：

```shell
git show <标签名>
```

创建一个**附注标签**，需要使用 -a  参数，使用 -m 参数填写标签信息： 

```shell
git tag -a <标签名> -m <标签信息>
```

> 默认情况下，`git push` 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。 这个过程就像共享远程分支一样 - 你可以运行 `git push origin [tagname]`。

将标签推送到远程仓库：

```shell
git push <分支名> <标签名>
```

也可以一次性将所有不在远程仓库中的标签推送过去：

```shell 
git push <远程仓库别名> --tags
```

### git branch 创建分支

> 关于*分支*：[《Pro Git 中文版（第二版）》](https://www.progit.cn/#_git_branching)

创建一个新的分支：

```shell
git branch <分支名>
```

上面这个命令仅仅会创建一个新的分支，不会自动切换到新分支中去。

查看各个分支指向的对象：

```shell
git log --oneline --decorate
```

查看所有分支和当前分支：

```shell
git branch
```

### git branch -d 删除分支

删除分支：

```shell
git branch -d <分支名>
```

注：如果分支上有未合并的工作，尝试删除时会失败。

查看已合并的分支：

```shell
git branch --merged
```

查看未合并的分支：

```shell
git branch --no-merged
```

### git checkout 切换分支

切换到已有的其他分支：

```shell
git checkout <分支名>
```

如果想新建一个分支并且切换到新分支上去，需要使用 -b 参数：

```shell
git checkout -b <分支名>
```

如果想在远程分支的基础上建立一个新的分支：

```shell
git checkout -b <分支名> <远程仓库别名>
```

如果想要将本地分支与远程分支设置为不同名字：

```shell
git checkout -b <本地分支名> <远程仓库别名>/<远程仓库分支名>
```

查看分支历史：

```shell
git log --oneline --decorate --graph --all
```

### git merge 合并分支

合并分支：

```shell
git merge <分支名>
```

**注**：如果想要将dev分支上的内容合并到master分支上，需要先检出到master分支上，然后在master分支上运行`git merge dev`指令。

如果合并出现冲突，此时需要对出现冲突的文件进行手动处理。处理好冲突后，还需要使用`git add`命令暂存文件，并使用`git commit`再次进行提交。

### 远程跟踪分支

> 远程跟踪分支是**远程分支**状态的引用。 它们是你不能移动的本地引用，当你做任何网络通信操作（`git clone/git fetch/git pull/git push`）后，它们会自动移动。 远程跟踪分支像是你**上次**连接到远程仓库时，那些分支所处状态的书签。

在和远程仓库进行通信（比如：`git clone/git fetch/git pull/git push`）之后，本地会存在**远程分支的引用**（叫做远程跟踪分支），引用以`<远程仓库名>/<远程仓库中的分支名>`命名。假如`git fetch`或者`git clone`之后，本地有了一个叫做`origin/dev`的**远程分支引用**。这个引用是不可修改的。之后，有其他人向这个远程分支上推送了新的代码。此时，我们本地的`origin/dev`不会自动更新，必须再次和远程仓库进行通信后（`git fetch`等等）才能更新。

在`git fetch`之后需要对远程跟踪分支进行手动合并：
```shell
git merge origin/dev
```

### git push <仓库> 推送分支

本地的分支不会自动和远程仓库进行同步，必须要手动推送想要推送的分支到远程服务器：

```shell
git push <远程仓库别名> <想推送的分支名>:<远程仓库别名>
```

如果想推送的分支名和远程仓库分支名相同，可以简写：

```shell
git push <远程仓库别名> <分支名>
```

### git push <仓库> --delete 删除远程分支

删除远程仓库中的分支：
```shell
git push <远程仓库别名> --delete <分支名>
```

### git rebase 变基分支

变基分支：
```shell
git rebase <分支名>
```

**注**：如果想要将dev分支上修改变基到master分支上，需要先检出到master分支上，然后执行上述命令。

> **风险准则**：**不要对在你的仓库外有副本的分支执行变基。**变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。 如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，如果你用 `git rebase` 命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。
>
> **总的原则**：只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作。

### git merge 和 git rebase 的区别？

git merge 和 git rebase 都是把另一个分支上的修改整合到当前分支上的操作。

merge 操作的原理是将两个分支的最新修改和他们的最近共同祖先进行三方合并。rebase 操作的原理是先找到两个分支的共同祖先，然后得到另一个分支相对于共同祖先的历次修改记录，并且将这些修改依次应用到当前分支上。

这两种做法在结果上没有区别。merge时需要一次合并信息，但是rebase不需要。所以rebase会让提交历史记录变得简洁。

### git rebase --onto 指定另一分支变基

在 b1 分支中，找出 b1 和 b2 分支共同祖先之后的修改，然后将这些修改应用到 b3 分支中：

```shell
git rebase --onto b3 b2 b1
```

### git reflog 引用日志

引用日志记录了最近几个月你的 HEAD 和分支引用所指向的历史，每当你的 HEAD 所指向的位置发生了变化，Git 就会将这个信息存储到引用日志这个历史记录里。：

```shell
git reflog
```

### git log <分支1>..<分支2> 提交区间

使用双点语法可以选出在一个分支中但是不再另一个分支中的提交。比如查看分支b2中还有哪些提交没有合并入b1：

```shell
git log b1..b2
```

### git add -i 交互式暂存

进入交互式暂存：

```shell
git add -i
```

### git stash 贮藏修改

如果工作到一半时需要切换分支，但是不想将完成一半的工作提交，可以使用git stash把当前修改贮藏到栈中：

```shell
git stash 
```

使用--keep-index参数可以指定Git不贮藏任何通过git add命令已暂存的东西：

```shell
git stash --keep-index
```

> 当你做了几个改动并只想提交其中的一部分，过一会儿再回来处理剩余改动时，这个功能会很有用。

默认情况下，git stash只会贮藏已经被跟踪的文件，如果想把未跟踪的文件也贮藏起来，可以使用-u参数：

```shell
git stash -u
```

使用--patch参数，Git 不会储藏所有修改过的任何东西，但是会交互式地提示哪些改动想要储藏、哪些改动需要保存在工作目录中：

```shell
git stash --patch
```

### git stash list 查看已贮藏的修改

查看已经贮藏的修改列表：

```shell
git stash list
```

### git stash apply 应用最近贮藏的修改

应用最近一次贮藏的修改：

```shell
git stash apply 
```

应用一个更旧的贮藏，可以通过名字指定：

```shell
git stash apply stash@{2}
```

> 可以在一个分支上保存一个储藏，切换到另一个分支，然后尝试重新应用这些修改。

### git stash pop 应用并删除最近贮藏的修改：

出栈：

```shell
git stash pop
```

### git stash drop 删除一个贮藏的修改：

删除最近一次贮藏的修改：

```shell
git stash drop
```

删除指定的贮藏记录：

```shell
git stash drop stash@{2}
```

###  git stash branch <分支名> 从贮藏创建分支

> 如果储藏了一些工作，将它留在那儿了一会儿，然后继续在储藏的分支上工作，在重新应用工作时可能会有问题。 如果应用尝试修改刚刚修改的文件，你会得到一个合并冲突并不得不解决它。 如果想要一个轻松的方式来再次测试储藏的改动，可以运行 `git stash branch` 创建一个新分支，检出储藏工作时所在的提交，重新在那应用工作，然后在应用成功后扔掉储藏。

### git clean 删除没有跟踪的文件

如果想将工作目录中没有被跟踪的文件删除，可以使用：

```shell
git clean 
```

上面的命令只能删除文件，如果想删除文件夹，可以使用-d参数：

```shell
git clean -d
```

使用-f参数强制执行：

```shell
git clean -d -f
```

使用-n参数，只查看将要删除什么不会进行删除：

```shell
git clean -d -n
```

默认情况下，`git clean` 命令只会移除没有忽略的未跟踪文件。 任何与 `.gitiignore` 或其他忽略文件中的模式匹配的文件都不会被移除。 如果你也想要移除那些文件，例如为了做一次完全干净的构建而移除所有由构建生成的 `.o` 文件，可以给 clean 命令增加一个 `-x` 选项：

```shell
git clean -n -d -x
```

也可以使用-i来进行交互式操作：

```shell
git clean -n -d -i
```

### git stash --all 清理工作目录并贮藏

git clean 清理之后无法找回，如果不想完全删除，可以使用 git stash --all 来贮存：

```shell
git stash --all
```

### git grep 从工作目录或者历史中查找字符串

可以从当前目录和历史提交中查找字符串或者正则表达式：

```shell
git grep <字符串或正则表达式>
```

### git 提交工作流钩子

前四个钩子涉及提交的过程。

`pre-commit` 钩子在键入提交信息前运行。 它用于检查即将提交的快照，例如，检查是否有所遗漏，确保测试运行，以及核查代码。 如果该钩子以非零值退出，Git 将放弃此次提交，不过你可以用 `git commit --no-verify` 来绕过这个环节。 你可以利用该钩子，来检查代码风格是否一致（运行类似 `lint` 的程序）、尾随空白字符是否存在（自带的钩子就是这么做的），或新方法的文档是否适当。

`prepare-commit-msg` 钩子在启动提交信息编辑器之前，默认信息被创建之后运行。 它允许你编辑提交者所看到的默认信息。 该钩子接收一些选项：存有当前提交信息的文件的路径、提交类型和修补提交的提交的 SHA-1 校验。 它对一般的提交来说并没有什么用；然而对那些会自动产生默认信息的提交，如提交信息模板、合并提交、压缩提交和修订提交等非常实用。 你可以结合提交模板来使用它，动态地插入信息。

`commit-msg` 钩子接收一个参数，此参数即上文提到的，存有当前提交信息的临时文件的路径。 如果该钩子脚本以非零值退出，Git 将放弃提交，因此，可以用来在提交通过前验证项目状态或提交信息。 在本章的最后一节，我们将展示如何使用该钩子来核对提交信息是否遵循指定的模板。

`post-commit` 钩子在整个提交过程完成后运行。 它不接收任何参数，但你可以很容易地通过运行 `git log -1 HEAD` 来获得最后一次的提交信息。 该钩子一般用于通知之类的事情。
