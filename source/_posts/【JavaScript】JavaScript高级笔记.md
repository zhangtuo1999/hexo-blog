---
title: 【JavaScript】JavaScript高级笔记
tags:
  - 前端
  - JavaScript
excerpt: 数据类型；垃圾回收；内存管理；对象；函数；原型与原型链
typora-root-url: ..
abbrlink: c2a65dc0
date: 2021-11-15 15:37:40
---

# 第一章 基础总结深入

## 1.1 数据类型

### 1.1.1 分类

简单数据类型--6种
1. String：任意的字符串

   * 可以以双引号、单引号或者反引号开头，没有任何区别，但是必须开头和结尾的符号必须一直
   * toString()方法，返回当前值的字符串等价物。toString()可以接受一个底数参数，默认10进制。null和undefined没有toString()方法。如果不确定一个值是不是null或undefined，可以使用String()转型函数。String()函数规则如下：
     1. 如果值有toString()方法，则调用toString()方法
     2. 如果值是null，则返回'null'；如果值是undefined，则返回'undefined'
   * 用加号操作符给值加上一个字符串''，也可以将其转换为字符串。

   * 用反引号表示模板字面量，会保留反引号内部的回车换行。模板字面量不是字符串，会在定义时自动求值转换成字符串。插值表达式`${}`内部的变量会调用toString()方法强制转换成字符串。插值表达式中可以调用函数和方法。

2. Number：任意的数字

   * 8进制：0开头，后面接上8进制数字（0-7）。如果0开头后面的数字中有不是8进制的数（8或9），会忽略前缀的0，后面的数值当作10进制数。严格模式下用0x开头

   * 16进制：0x开头，后面跟上16进制的数字或字母（大小写均可）

   * 使用8进制和16进制创建的数值再所有数学操作中都被视为10进制。

     ```js
     console.log(067 + 0xA)  //(55+10)  65
     ```

   * NaN不等于包括自己在内的任何值。isNaN()函数接收一个参数。可以是任意数据类型，然后判断这个参数是否不是数值。

     ```js
     console.log(NaN,isNaN(NaN))   		//NaN true
     console.log(1111,isNaN(1111))		//1111 false
     console.log('1111',isNaN('11111'))	//1111 false
     console.log('111a',isNaN('111a'))	//111a true
     console.log('aaa',isNaN('aaa'))		//aaa true
     console.log(true,isNaN(true))		//true false
     console.log(false,isNaN(false))		//false false
     ```

     isNaN也可以测试对象，先调用对象的valueOf()方法，然后再确定返回值是否可以转换为数值。如果不能再调用toString()方法，并测试返回值。

   * 浮点数都是双精度。如果可以用整数表示，那么就用整数来存储

   * Number()转型函数，转换规则如下：

     1. Boolean：true转换成1，false转换成0
     2. Number：直接返回
     3. Null：null转换成0
     4. Undefined：undefined转换成NaN
     5. String：
        * 如果字符串包含数值字符，包括前面带正负的情况，转化成一个10进制的值。忽略前缀的0。可以是整数或者时浮点数
        * 字符串是有效的8进制或16进制（0o或0x开头），则会转换成对应的8进制或者16进制
        * 空串返回0
        * 不属于以上几种情况的，返回NaN

   * parseInt()和parseFloat()：将字符串转为数值

     parseInt()检测到第一个不是数值的字符为止，如果检测到了字符串的末尾返回数值，如果没有，就返回NaN。如果传入的不是Number类型或String类型，会直接返回NaN

     paraseInt()可以接受第二个参数，用于指定底数。如果指定了底数，第一个参数字符串就不用加上前缀了

     parseFloat()始终忽略前缀的0，但是parseFloat()只能解析10进制的数值，因此不能指定底数。

3. Boolean：true/false

   * Boolean()转型函数，可以将所有类型的值转为相应布尔值的等价形式，转换规则如下：

     | 数据类型  | 转换为true的值         | 转换为false的值 |
     | --------- | ---------------------- | --------------- |
     | Boolean   | true                   | false           |
     | String    | 非空字符串             | ''              |
     | Number    | 非零数值（包括无穷值） | 0、NaN          |
     | Object    | 任意对象               | null            |
     | Undefined | -                      | undefined       |

   * if等流控制语句会自动执行其他类型数值到布尔值的转换

4. Undefined：undefined

   * 声明了但未初始化的变量，默认赋值undefined

   * 对于未声明的变量只能调用typeof。对未声明的变量和声明了但是没赋初值的变量调用typeof，结果都是字符串'undefined'

5. Null：null

   * 表示一个空对象指针，定义将来要保存对象值的变量时，建议使用null来进行初始化，不要用其他值。

     ```js
     console.log(null == undefined)	//true
     console.log(undefined === null) //false
     ```

   * null和undefined的区别：undefined代表定义了但是没有初始化，null代表空对象引用，可以理解为赋值了，只不过值为null，没有实际意义。将变量的初始值赋值为null，表示将要把这个变量赋值为对象。将一个对象变量赋值为null时，运行时会释放变量的内存。

6. Symbol：任意的符号

   * Symbol()函数不能用作构造函数，与new关键字一起使用。但是可以借用Object()函数创建符号包装对象。
   * 共享和重用符号实例可以使用全局符号注册表。Symbol.for()接受一个字符串作为键，在全局符号注册表中创建并重用符号。可以使用Symbol.keyFor()来查询全局注册表，接受符号返回该全局符号的字符串键，如果查询的不是全局符号，返回undefined。如果传给Symbol.for()的不是符号，则抛出错误。
   * 对象字面量只能在计算属性中使用符号作为属性。Object.defineProperty()和Object.defineProperties()也可以定义符号属性。
   * Object.getOwnPropertyNames()返回对象实例的常规**属性**数组。Object.getPropertySymbols()返回对象实例的符号**属性**数组。上面这两个方法互斥。Object.getPropertyDescripteors()都返回常规属性和符号属性的描述符对象。Refilect.ownKeys()会返回两种类型的键。
   * ES6引入了一些常用内置符号，用于暴露语言内部行为。

复杂数据类型--1种
1. Object：任意对象

   * Function：一种特别的对象（可以调用执行）
   * Array：一种特别的对象（数值下标，内部数据有序）
   * 对象就是一组数据和功能的集合

### 1.1.2 判断

* typeof操作符
  * typeof返回的是数据类型的字符串表达，返回值一共有7种。没有'null'但是多个一个'function'
  
    * 'undefined'
    * 'boolean'
    * 'string'
    * 'number'
    * 'object'：表示值为对象而不是函数，或者值为null。（null被认为是一个空对象的引用）
    * 'function'：表示值为函数
    * 'symbol'
  
  * typeof是一个操作符而不是函数，所以不需要参数，但是可以使用参数
  
    ```javascript
    console.log(typeof message)
    console.log(typeof(message))
    ```
  
  * 不能判断null和array类型，因为返回的都是字符串'object'
  
* instanceof
  
  * A instanceof B：判断A是不是B的一个实例。B是一个构造函数，A是一个实例对象
  * 可以判断对象的具体类型，一个函数还是一个数组
  
* ===

  * 可以判断undefined和null

### 1.1.3 变量类型和数据类型的区别

* 数据类型：简单数据类型（6种）和复杂数据类型（对象）
* 变量类型：基本类型和引用类型
* 变量值：原始值和引用值

## 1.2 数据、变量、内存

### 1.2.1 数据

* 存储在内存中，代表特定信息

### 1.2.2 内存

* 可存储数据的临时空间

* 栈内存：全局变量和局部变量

* 堆内存：对象

```js
  let a = xxx
```

  * 如果xxx是简单数据，则a内存中保存的是这个数据
  * 如果xxx是对象，则a内存中保存的是这个对象的地址值

 ```js
  let a = xxx
  let b = a
 ```

  * 如果xxx是简单数据，则b内存中保存的是这个数据的值
  * 如果xxx是对象，则b内存中保存的是对象的地址值

### 1.2.3 变量

* 可变化的量，由变量名和变量值组成

* 每个变量都对应一块内存，变量名用来查找对应的内存，变量值就是内存中保存的数值数据

  ```js
  let obj = {name:'Tom'};
  let a = obj
  
  obj.name = 'Jack'
  console.log(a.name) //Jack
  ```

  obj中保存值的是{name:'Tom'}这个对象数据的地址值，`let a = obj` 这条语句的作用是将obj中保存的值（也就是对象数据的地址）拷贝一份赋值给a。obj和a中保存的内容是一样的，都是{name:'Tom'}这个对象。所以通过obj修改对象的数据后，a指向的内容是修改过的数据。

```js
  let a = {x:100}
  function f(obj){
  	obj.x = 200
  }
  f(a)
  console.log(a)	//{x:200}
```

```js
  let a = {x:100}
  function f(obj){
  	obj = {x:200}
  }
  f(a)
  console.log(a)	//{x：100}
```

* 上面第一种可以通过obj取对象的数据，并进行修改。这种修改实参也会看到对象被修改。第二种是将一个新对象的地址赋值给了obj，没有对原对象进行修改由于a变量种保存的仍然是原对象的地址值，多以a对象看不到修改后的内容。

* js调用函数时传递变量参数时，是值传递还是引用传递?说法1：值传递。这个值可能是简单数据类型的值，也可能是对象的地址值。说法2：可能是值传递，也可能是引用传递（地址值）。

### 1.2.4 内存释放

 ```js
  function f(){ let b = {}}
  f()
 ```

* 上面的例子中，b是局部变量。函数f()执行完后，b会自动释放，而b所指向的对象在后面的某个时刻由垃圾回收器回收。全局变量不会释放。

## 1.3 垃圾回收

* js是使用垃圾回收的语言，通过自动内存管理实现内存分配和闲置资源回收。基本思路是，确定哪个变量不会再使用，然后释放它占用的内存。因此，垃圾回收程序必须跟踪记录哪个变量还会使用，以及哪个变量不会再使用。
* 两种策略：标记清理（最常用）和引用计数

### 1.3.1 标记清理

* 变量进入上下文时，将其标记为‘进入上下文’；变量离开上下文时，将其标记为‘离开上下文’。
* 垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。

### 1.3.2 引用计数

* 当声明了一个变量并将一个引用类型值赋值该变量时，则这个值的引用次数就是1.如果同一个值又被赋给另外一个变量，则该值得引用次数加1。相反，如果包含对这个值引用的变量又取 得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那 些引用次数为零的值所占用的内存。 

* 问题：循环引用。循环引用指的是对象A中包含一个指向对象B的指针，而对象B中也包含一个指向对象A的引用。

  ```js
  function problem(){     
      var objectA = new Object();
      var objectB = new Object(); 
   
      objectA.someOtherObject = objectB;
      objectB.anotherObject = objectA; 
  }
  ```

  在这个例子中，objectA 和 objectB 通过各自的属性相互引用；也就是说，这两个对象的引用次数都是 2。

  在采用标记清除策略的实现中，由于函数执行之后，这两个对象都离开了作用域，因此这种相互引用不是个问题。但在采用引用计数策略的实现中，当函数执行完毕后，objectA 和 objectB 还将继续存在，因为它们的引用次数永远不会是 0。假如这个函数被重复多次调用，就会导致大量内存得不到回收。


## 1.4 内存管理

* 优化内存占用的最佳手段就是保证执行代码时只保存必要的数据。解除引用：如果数据不在必要，将其设置为null，从而释放其引用。解除对一个值的引用并不会自动导致相关的内存被回收。解除引用的关键在于确保相关的值不在上下文中吗，以便下次垃圾回收时会被回收。

# 第二章 对象与函数

## 2.1 对象

### 2.1.1 对象的组成

* 属性
* 方法

### 2.1.2 属性

* 属性由属性名和属性值组成，属性名一定是字符串。属性值为任意类型。

### 2.1.3 方法

* 一种特别的属性，属性的值是函数

### 2.1.4 访问方法

* 使用.进行访问属性，有时不能用。属性名包含特殊字符。或者是符号属性。
* 使用[属性名字符串]，通用

## 2.2 函数

* 只有函数可以执行，其他数据不可执行

* 定义方式：函数声明形式 函数表达式形式
* 调用方式：
  * ()
  * text.call/apply(obj)：临时让test成为obj的方法进行调用

* 回调函数：dom事件回调函数，定时器回调函数
  * 只定义了没有调用，最后执行了
* 函数中的this
  * 任何函数本质上都是通过某个对象来调用的，如果没有指定即使window
  * 所有函数内部都有一个变量this
  * this的值是调用函数的当前对象

* 确定this的值
  * test():window
  * p.test():p
  * new test():新创建的对象
  * p.call(obj):obj

* js分号问题
  * 什么时候不加分号会出现问题：小括号或中括号开头的前一条语句。

# 第三章 原型与原型链

## 3.1 原型

* 每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象)
* 原型对象中有一个属性constructor, 它指向函数对象
* 每个函数function都有一个prototype，即显式原型
* 每个实例对象都有一个`__proto__`，可称为隐式原型
* 对象的隐式原型的值为其对应构造函数的显式原型的值

## 3.2 原型链

* 原型链是用来查找对象的属性的，想查找变量要用到作用域链

```js
function Fn() {
    this.test1 = () => {
        console.log("test1()");
    };
}
Fn.prototype.test2 = () => {
    console.log("test2()");
};
let fn = new Fn();
fn.test1();   //test1属性在Fn的实例对象fn上
fn.test2();   //test2属性在Fn的原型对象Object空对象上
console.log(fn.toString()); //toString属性在Object的原型对象上
fn.test3();   //原型链中无test3属性
```

![uTools_1638774048683](/images/JavaScript高级笔记/uTools_1638774048683-16388599608671.png)

访问一个对象的属性时：

1. 先在自身属性中查找，然后返回
2. 如果没有，沿着`__proto__`这条链向上查找，找到返回
3. 如果最后没有找到，返回undefined

* 原型链是按照隐式原型链进行查找的
