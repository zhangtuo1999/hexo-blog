---
title: 【项目】尚品汇项目要点笔记
tags:
  - 前端
  - Vue
  - Vuex
  - Vue Router
excerpt: 实战 Vue 大型电商项目：尚品汇（前台项目）
typora-root-url: ..
abbrlink: 33e93e4
date: 2022-03-29 10:24:08
---

>* 项目视频教程：https://www.bilibili.com/video/BV1Vf4y1T7bw
>* 项目代码仓库：https://github.com/zhangtuo1999/shangpinhui

## 001 - 003

### 1. Vue CLI 创建出来的 Vue 项目的目录结构

<img src="/images/尚品汇项目要点笔记/image-20220329151858424.png" alt="image-20220329151858424" style="zoom: 67%;" />

### 2. 运行项目后，浏览器自动打开

在 package.json 文件中：

```json
{
  "scripts": {
    "serve": "vue-cli-service serve --open",
  }
}
```

### 3. src 文件夹别名

在 jsconfig.json 文件中：

```json
{
  "compilerOptions": {
    "paths": {
      "@/*": [
        "src/*"
      ]
    },
  }
}

```

## 004 - 005

### 1. 分析项目路由

路由组件：

Home、Search、Login、Register

非路由组件：

Header 和 Footer（在首页、搜索页有 Footer，在登录页和注册页没有 Footer）

### 2. 开发项目的一般流程

1. 写静态页面（HTML + CSS）
2. 拆分组件
3. 获取服务器数据
4. 完成相关动态业务逻辑

### 3. 安装 less 相关依赖

安装的 less-loader 版本过高会发生错误，所以将 less-loader 版本限定到5。

```bash
npm install --save less less-loader@5
```

在 `<style>` 标签后添加 `lang="less"` 使 Vue 组件识别 less 样式。

### 4. 使用非路由组件流程

1. 创建组件
2. 引入
3. 注册
4. 标签形式使用

## 006 - 009

### 1. 安装 Vue Router 3.x

Vue 2.x 项目需要搭配 Vue Router 3.x 实现路由功能：

```bash
npm install 
```

### 2. 配置路由

把路由配置写在 src/router/index.js 下

```JS
import Vue from 'vue'
import VueRouter from 'vue-router'

Vue.use(VueRouter)

import Home from "@/pages/Home";

export default new VueRouter({
    routes: [
        {
            path: '/home',
            component: Home
        },
    ]
})
```

### 3. 路由组件和非路由组件的区别

1. 路由组件一般放置在 pages 或 views 文件夹中；非路由组件一般放在 components 文件中。
2. 路由组件一般需要放在 router 文件夹中进行注册，使用的即为组件的名字；非路由组件一般使用标签形式进行使用。
3. 路由组件和非路由组件身上都有 `$route` 和 `$router` 属性。
   * `$route`：一般获取路由信息，比如 path，query 和 params 等信息。
   * `$router`：一般用来进行编程式路由导航，比如 push 和 replace。

### 4. 路由的跳转

声明式导航：`router-link`

编程式导航：`this.$router.push()` 和 `this.$router.replace()`

### 5. 设置 Footer 组件的显示与隐藏

1. 在路由的配置项中，设置路由的元信息
2. 使用 v-if 或者 v-show 判断是否显示 Footer 组件

### 6. 路由跳转的几种方法

1. 声明式导航：使用 `<router-link>` 标签（必须带有 `to` 属性）
2. 编程式导航：使用组件实例上的 `$router.push()` 和 `$router.replace()` 方法

### 7. 路由传参

1. params 参数：属于路径中的一部分，配置路由时需要**占位**
2. query 参数：不属于路径中的一部分

注意：如果需要传 params 参数，不能使用 path 的形式，只能使用 name 的形式。即：如果提供了 path，params会被忽略。详见：https://v3.router.vuejs.org/zh/guide/essentials/navigation.html

### 8. 路由相关面试题

1. 路由传递参数，path 是否可以结合 params 参数一起使用？

   不可以。如果提供了 path，params 会被忽略。取而代之的是，需要提供路由的 name 或手写完整的带有参数的 path。

2. 如何让指定 params 参数可传可不传？

   **问题描述**：在路由配置中，如果使用了 params 并且使用占位符。但是如果在路由导航时不传递 params 参数，此时 URL 是错误的。例如：

   在路由配置中：

   ```
   {
       path: '/search/:keyword',
       name: 'search',
       component: Search,
       props: true,
       meta: {showFooter: true}
   }
   ```

   编程式路由导航（并未传递 params 参数）：

   ```
   router.push({name: 'search'})
   ```

   错误效果：

   URL：`http://localhost:8080/#/`（正确的 URL 应为：`http://localhost:8080/#/search`）

   如果想**正确解决**上述问题，需要在路由配置中：

   ```
   {
   	path:'/search/:keyword?'
   }
   ```

3. 在 params 参数可传可不传的情况下，如何解决传递空串的问题？

   **问题描述**：在配置 params 参数可传可不传后，如果传递了空串，同样会导致 URL 显示错误。例如：

   在路由配置中：

   ```
   {
       path: '/search/:keyword',
       name: 'search',
       component: Search,
       props: true,
       meta: {showFooter: true}
   }
   ```

   编程式路由导航（传递的 params 参数是一个空串）：

   ```
    router.push({name: 'search',params:{keyword:''}})
   ```

   错误效果：

   URL：`http://localhost:8080/#/`（正确的 URL 应为：`http://localhost:8080/#/search`）

   如果想**正确解决**上述问题，需要在 params 中使用 undefined 来代替空串（使用管道符更简便）：

   ```
    router.push({name: 'search',params:{keyword:''||undefined}})
   ```

4. 路由组件能不能传递 props 数据？

   可以。有三种写法。参考：https://v3.router.vuejs.org/zh/guide/essentials/passing-props.html

   * 布尔模式

     **仅限传递 params 参数**。如果 `props` 被设置为 `true`，`route.params` 将会被设置为组件属性。

     路由配置中：

     ```
     {
         path: '/search/:keyword?',
         name: 'search',
         component: Search,
         props: true,
         meta: {showFooter: true}
     },
     ```

     组件中，使用 props 接收参数：

     ```
     props: ['keyword']
     ```

   * 对象模式

     ```
     {
         path: '/search/:keyword?',
         name: 'search',
         component: Search,
        	props: {a: 100, b: 'foo'},
         meta: {showFooter: true}
     }
     ```

## 010

### 编程式路由导航跳转到当前路由（参数不变），连续执行会抛出  NavigationDuplicated 错误

**问题描述**：使用 `router.push({name: 'search', params: {keyword: 'foo'}})` 跳转路由，如果连续两次导航到同一路由并且参数不变，会抛出下面的错误：

```
Uncaught (in promise) NavigationDuplicated: Avoided redundant navigation to current location: "/search/foo"
```

**原因分析**：Vue Router  引入了 Promise，push 和 replace 函数的返回值是一个 Promise 对象。

**解决方案**：

1. 给 push 或 replace 函数传入成功和失败的回调函数，例如：

   ```
   this.$router.push({name: 'search', params: {keyword: this.keyword}},()=>{},()=>{})
   ```

2. 封装 push/replace 方法并覆盖 VueRouter.prototype.push / VueRouter.prototype.relpace，例如在 src/router/index.js 中：

   ```js
   // 重写 push 和 replace 方法，以解决多次访问相同参数的路由时出现的 NavigationDuplicated 错误
   const originPush = VueRouter.prototype.push
   const originReplace = VueRouter.prototype.replace
   
   VueRouter.prototype.push = function (location, resolve, reject) {
       if (resolve && reject) {
           originPush.call(this, location, resolve, reject)
       } else {
           originPush.call(this, location,
               () => {
               },
               () => {
               }
           )
       }
   }
   
   VueRouter.prototype.replace = function (location, resolve, reject) {
       if (resolve && reject) {
           originReplace.call(this, location, resolve, reject)
       } else {
           originReplace.call(this, location,
               () => {
               },
               () => {
               }
           )
       }
   }
   ```

注意：声明式导航不会出现上述的问题。

## 011 - 017

### 1. axios 二次封装

为什么要封装 axios？为了配置请求拦截器、响应拦截器。

在 src/api/request.js 中：

```js
/**
 * 对 axios 进行二次封装
 */

import axios from "axios";

// 1. 利用 axios 对象的 create 方法创建一个 axios 实例
// 这里的 request 就是 axios 的一个实例
const service = axios.create({
    // 1. 设置基础路径,在服务器地址和接口之间加上'/api'
    // 以后想发请求/api/user/list,只需要发请求/user/list即可，接口地址会自动加上/api
    baseURL: '/api',

    // 2. 设置请求超时时间5s
    timeout: 5000
})

// 2. 配置请求拦截器
service.interceptors.request.use((config) => {
    return config
})

// 3. 配置响应拦截器
service.interceptors.response.use(
    // 1. 响应成功的回调，只返回data字段
    (res) => {
        return res.data
    },
    // 2. 响应失败的回调
    (err) => {
        return Promise.reject(new Error('Error'))
    }
)


export default service

```

### 2. 跨域问题

* 浏览器从一个地址访问另一个地址，如果这两个地址的协议、服务器地址、端口三者只要有一个不一样就算跨域。

### 3. 配置代理解决

在 vue.config.js 中：

```js
const {defineConfig} = require('@vue/cli-service')
module.exports = defineConfig({
    transpileDependencies: true,
    devServer: {
        proxy: {
            '/api': {
                target: 'http://39.98.123.211/',
            }
        }
    }
})
```

### 4. NProgress 进度条

地址：https://github.com/rstacruz/nprogress

## 018 

### 使用 Vuex 模块化开发

参考：https://v3.vuex.vuejs.org/zh/guide/modules.html

## 019 - 021

### 使用 js 实现三级联动效果

## 022

### 函数的防抖与节流

* 防抖（debounce）：前面所有的函数触发都取消，最后一次执行在规定的时间之后才会触发。即，连续快速的触发，只会执行一次。（实现：闭包+定时器）

* 节流（throttle）：在规定的间隔时间范围中不会重复触发回调，只有大于这个时间间隔才会触发回调，把频繁触发变为少量触发。（实现：闭包+定时器）

## 023 - 028

### 事件委派+编程式路由导航+自定义属性实现三级联动路由跳转

## 029 - 036

### 使用 watch + $nextTick() 解决 mounted 中无法获取 dom 的问题

## 037 - 038

### 组件间通信：

1. props：父子组件通信
2. 自定义事件：@on @emit 子给父通信
3. 全局事件总线
4. pubsub
5. 插槽
6. vuex

## 039 - 046

1. 如果在项目中看到很多地方公用一个组件，可以将这个组件拆分出来，注册为全局组件。
2. 项目中 vuex getters 的主要作用是简化仓库中的数据
2. 深度监听

## 047 - 049

### 1. 全局事件总线实现兄弟组件传参

### 2. 自定义事件实现子给父传参

## 050 - 053

## 054 - 
