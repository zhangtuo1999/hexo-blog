## js

* var let const 之间的异同点

  * **作用域**：
    * var 声明的变量属于函数作用域。在函数外使用 var 声明变量时，该变量会成为全局变量。

    * let 和 const 声明的变量属于块作用域。

  * **声明提升**：
    * var 存在声明提升。使用 var 声明变量时，变量的声明会提升到作用域的顶部，因此可以在声明变量的语句前访问到这个变量，值是 undefined。

    * let 和 const 不存在声明提升。在声明变量语句前访问变量会报错，也就是存在暂时性死区。

    * 函数有声明提升，类没有
    
  * **重复声明**：
    * 使用 var 声明的变量可以在同一作用域内重复声明。
    * 使用 let 和 const 声明的变量不可以在同一作用域内重复声明。
  * **赋值**：
    * var 和 let 可以先声明后赋值，赋值后可以重新赋值。
    * const 必须在声明变量时同时赋值，赋值后不可以重新赋值。
  
  * *代码规范*：一般来说，声明变量时，优先使用 const，如果认为这个变量会重新分配，那就使用 let，任何时候都不要使用 var。
  
* for-in 和 for-of 区别

  * for-in 用来遍历对象除 Symbol 外的可枚举属性名，包括继承的可枚举属性。for-in 会根据对象属性描述符上的 enumerable 来判断对象的属性是否可枚举。不保证遍历顺序。一般是，先遍历数字属性再遍历字符串属性，数字属性按数字大小排列，字符串属性按添加顺序遍历。
  * for-of 用来遍历可迭代对象。for-of 会根据可迭代对象身上的 [Symbol.iterator] 方法进行遍历。常见的可迭代对象有数组、字符串、map、set、arguments 对象、NodeList 对象。
  * 直观感受是，for-in 用来遍历键，for-of 用来遍历值。
  
* 数据类型

  * boolean string number undefined null symbol bigint object
    * symbol es6
    * bigint es2019
      * 可以表示大于 2^53-1 的数值

  * null 和 undefined 区别
    * null 代表空值，undefined 代表未定义的值。undefined 是自己出现的，一般不会显式赋值一个变量为 undefined
    * null 出现场景：
      * 声明对象但是暂不赋值，一般初始化为 null
      * 当变量不再被使用时，赋值为 null 来解除引用
    * undefined 出现场景：
      * typeof 后跟一个没声明的变量
      * 声明变量但没赋值
      * 函数没有 return，或者 return 空表达式
      * 定义形参但没有传参
      * 对象上没有对应的属性
  * 为什么 null 会被 typeof 判断成对象
    * JavaScript 设计上的失误。在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的（对象的类型标签是 0）。由于 null 代表的是空指针（大多数平台下值为 0x00），因此，null的类型标签也成为了 0，typeof null就错误的返回了"object"。

  - 如何检测数据类型，不同场景不同方案

    - instanceof  和 typeof 区别
      - typeof 检测变量的类型，可以准确检测除 null 外的基本数据类型和函数
      - instanceof 用来检测右侧构造函数是否出现在左侧实例对象的原型链上
    - 判断空对象
      - Object.keys(obj).length === 0 配合 obj.constructor === Object
      - Object.prototype.toString().call(obj) 配合 JSON.stringify(value) === '{}'
    - 判断数组
      - isArray
    - 通用的解决方案是调用 Object.prototype.toString().call(obj)
  - 基本类型和引用类型的区别
    - 定义：基本类型值指的是简单的数据段；引用类型值指那些可能由多个值构成的对象
    - 内存空间：js 内存分为栈内存和堆内存
      - 基本类型变量以及变量的值存放在栈内存中
      - 引用类型变量的地址存放在栈内存中，值存放在堆内存中
    - 对值的操作：
      * 基本类型按值访问，操作的是实际保存的值
      * 引用类型按地址访问，先从栈中读取内存地址，然后按照内存地址到堆内存中取值
    - 变量赋值：
      * 将一个基本类型变量赋值给一个新变量，会在栈中创建一个新值，然后把值赋给新变量
      * 将一个引用类型变量赋值给一个新变量，赋值的是存在栈内存中的地址，两个变量会引用同一个对象。所以修改其中一个变量，另一个变量也会发生改变。
  - == 和 ===
    - == 相等：先进行类型转换，然后判断
    - === 严格相等：不进行类型转换，直接判断

* 数值

  * MAX_SAFE_NUMBER 最大安全整数 2^53 - 1 

* 对象

  * new 一个对象的中间过程
    1. 在内存中创建一个新的对象
    2. 新对象的隐式原型指向构造函数的显式原型
    3. 构造函数内部的 this 指向新对象
    4. 执行构造函数内的代码
    5. 如果没有显式返回值，返回该对象
  * 深拷贝、浅拷贝
    * 深拷贝和浅拷贝都复制值和地址，都是为了解决引用类型赋值后相互影响的问题
      * 浅拷贝进行一层复制，深层次的引用类型还是共享内存地址
      * 深拷贝是无限层级复制，拷贝后原对象和新对象互不影响
    * 浅拷贝：
      * Object.assign()
      * 扩展运算符
    * 深拷贝
      * JSON.parse(JSON.stringfiy(obj)) 缺点：
        * 忽略 undefined symbol function
        * NaN、Infinity 会被序列化为 null
        * 存在循环引用的问题
      * 手写深拷贝
        * 处理 typeof 不为 object 的情况：除 null 外原始类型和函数
        * 处理 null
        * 处理日期、正则、NodeList
        * 处理对象、数组
        * 解决循环引用
  * 遍历对象属性
    * for-in 遍历对象身上除 Symbol 外的可枚举属性名，包括继承的可枚举属性。
    * 如果不想遍历原型身上的属性，可以使用 hasOwnProperty() 方法加判断。或者使用 Object.keys()。
    * Object.keys() 返回对象身上除 symbol 外的可枚举属性名，不包括继承的可枚举属性。
    * Object.getOwnPropertyNames()，返回对象自身上除 Symbol 外的属性名，包括不可枚举属性。
    * Object.getOwnPropertySymbols()，返回对象自身上的 Symbol 属性。
    * Reflect.ownKeys()，返回对象身上的属性，包括字符串属性和符号属性。
  * 继承的实现方式（todo）
    * 原型链继承
      * 子类构造函数原型指向父类构造函数的实例
      * 优点：可以继承父类实例以及父类原型的属性和方法
      * 缺点：
        * 父类引用类型属性会被子类共享，一个子类修改父类引用类型属性后，其他子类也会被影响。
        * 子类无法给父类构造函数传参
    * 构造函数继承
      * 子类构造函数内部调用父类构造函数
      * 优点：子类间不会相互影响父类的引用类型属性，子类可以给父类构造函数传参
      * 缺点：子类无法访问到父类原型上的属性和方法
    * 组合继承
      * 子类构造函数内部调用父类函数，并且子类构造函数原型指向父类构造函数的实例
      * 优点：子类间不会相互影响父类的引用类型属性，子类可以给父类构造函数传参，子类可以访问到父类原型上的属性和方法
      * 缺点：父类的构造函数会被调用两次。父类的属性和方法不仅会存在子类实例上，还会存在子类实例的原型链上。存在性能问题。
    * 原型式继承
    * 寄生式继承
    * 组合寄生式继承
    * es6 extends

* 数组

  * 数组方法有哪些
    * 改变原始数组的
      * push pop shift unshift reverse splice sort
    * 迭代方法
      * forEach filter map every some

* 函数

  * this 总是指向函数执行时的当前对象
    * 作为对象的方法调用
      * this 指向该对象

    * 作为普通函数调用
      * this 指向全局对象

    * 作为构造函数调用
      * this 指向返回的这个对象

    * call 和 apply
      * this 指向传入的参数


  - 箭头函数
    - 怎么介绍箭头函数？哪些特性？
      - 箭头函数是es6新增的使用箭头来定义的函数，语法更简洁、功能受限。
    - 箭头函数和普通函数的区别
      - 箭头函数没有 prototype 属性。不能使用 arguments、super 和 new.target，也不能用作构造函数。箭头函数的 this 指向定义箭头函数的作用域
  - 尾递归优化

    - 尾递归：函数的返回值是调用自身
    - 尾递归优化：函数执行时有一个调用栈。满足尾递归时，帧在压入调用栈前会先弹出上一个帧。无论递归多少次，调用栈中只有一个帧

  - call apply bind
    - call 和 apply 功能相同，都是以指定的 this 值来调用函数。call 和 apply 的一个参数都是指定的 this 值。但是 call 和 apply 之后传参的方式不同：call 是将从第二个开始的参数一个个传给原函数；apply 是将第二个参数作为参数数组，拆分后传给原函数。
    - bind 的传参方式和 call 相同，但是不会执行函数，而是返回一个新的函数。返回的新函数中的 this 就是传入的 this 值。

* 异步

  * 对 promise 的理解。解决了什么问题？用法？方法？
    * 解决回调地狱问题。
    * 三种状态。pending、fulfilled/resolved、rejected。
    * 控制状态。通过调用执行器函数的两个参数可以改变 promise 的状态。一般被命名为 resovle 和 reject。
    * 直接创建 resolved 或者 rejected 状态的 promise 对象。 Promise.resolve()、Promise.reject() 
    * then()、catch()、finally() 方法，用来访问异步操作返回的数据。可以链式调用
    * Promise.all()、Promise.allSettled()、Promse.race()、Promise.any()
      * Promise.all()：当传入的 promise 对象数组全兑现时，Promise.all() 返回的 promise 对象也被兑现，兑现的值是所有兑现值的数组（按传入数组的顺序）；只要有一个 promise 对象被拒绝，Promise.all() 返回的 promise 对象会立刻被拒绝，拒绝原因是第一个 promise 对象拒绝的原因。
      * Promise.allSettled()：等待所有的传入的 promise 对象解决或者拒绝，Promise.allSettled 会被兑现，兑现值是所有 promise 解决值或者拒接原因的对象数组。
      * Promise.race()：根据传入的 promise 对象数组首先落定的 promise 状态，如果首先落定为解决，返回的 promise 就解决，如果首先落定为拒绝，返回的 promise 就拒绝。解决值和拒绝理由和首先落定的对象相同。
      * Promise.any()：当传入的 promise 数组有一个解决时，Promise.any() 返回的 promise 就解决，解决值相同。当传入的 promise 都拒绝时，返回的对象才拒绝，拒绝原因是所有拒绝原因的数组。


  - async await

    - async 标识一个函数为异步函数。异步函数内部的返回值会被 Promise.resolve() 包装成一个 promise 对象。
    - await 可以阻塞异步函数后面的代码，等待异步函数执行完毕后，对异步函数的返回的 promise 对象进行解包。await 只能在异步函数中使用，不能在顶级上下文中使用。

* 客户端存储

  * cookie
    * name/value/domain/path
      * cookie 的名、值、访问哪些域会带上这个 cookie（只区分域，与协议和端口无关）、哪些目录可以共享这个 cookie
    * samesite
      * strict：完全禁止 cookie 发送到第三方网站
      * lax（默认）：允许部分操作（ a 标签、预加载请求、get 表单）携带 cookie 发送到第三方网站。可以防止 csrf 攻击
      * none：不限制 cookie 发送到第三方网站
    * httponly
      * 设置后，cookie 不能通过 JavaScript 操作。可以防止 xss 攻击
    * secure
      * 设置后，只有 https 协议才能携带该 cookie，http 协议不能携带该 cookie
    * expires/maxage
      * 过期时间。expires 是 http 1.0 的用法，值是绝对时间。maxage 是 http 1.1 的用法，优先级更高，值是相对时间，单位秒
  * cookie session token（todo）
    * cookie 和 session
    * token


  - localStorge sessionStorge
    - 相同点
      - 作用：在客户端存储数据
      - API：key() getItem() setItem() removeItem() clear()
      - 存储大小：最大5m
    - 不同点
      - 生命周期：localStorge 里的数据可以长期保留，sessionStorge 里的数据会在页面关闭时清除
      - 作用域：localStorge 里的数据可以在同源文档间共享，sessionStorge 里的数据只能在同一页面会话中共享

* 路由

  * 什么是路由？

    * 路由把URL转发到对应的视图上。SPA 中，浏览器地址的变化不会引起网页的重新加载。路由主要通过监听事件，动态改变网页的内容。主要有 hash 和 history 两种模式。
  * history 和 hash 路由的区别？

    * 用户能感知到的区别是，hash 路由在地址栏中会有一个#，history 路由没有
    * 实现路由的方式不同：
      * hash 模式通过监听 hashchange 事件，执行回调函数来改变页面；

      * history 模式主要利用重写的history.pushState()、history.replaceState()方法，使其触发 popstate事件，再监听popstate事件实现路由

    * hash 模式不需要后端配合，history模式需要后端配合。因为history模式下，刷新页面会向服务器发送请求，默认请求url下的index.html，服务器没有这个资源就会报错
  * hash 模式：
    * 地址栏中的hash变化时，网页不会刷新
    * 实现路由的方式：监听 windows 的 hashchange 事件。
    * 可以通过 windows.location.hash 来获取和设置 hash。windows.location.hash 的变化会直接显示到地址栏。
  * history 模式：
    * history 对象表示当前窗口的浏览历史。history 对象发生变化时，地址栏会变化，但是不会刷新页面
    * 实现路由的方式：监听 popstate 事件。
    * history.back()、history.forward()、history.go() 
      * 后退、前进、跳转。在历史记录中跳转。
      * 会触发popstate事件
    * history.pushState()、history.replaceState()
      * 将页面压入历史记录栈中、将页面替换历史记录栈最上面的页面
      * 不会触发 popstate 事件

* 节流防抖
  * 防抖
    * 在事件触发的n秒后再执行回调函数，如果n秒内再次触发，则重新开始计时。类似于lol中的回城机制。
    * 应用场景：文本框输入后搜索、表单项验证
  * 节流
    * 在事件触发后n秒内不能再次触发。类似于lol中的技能cd。
    * 应用场景：避免按钮高频点击、避免表单重复提交
  
* 事件循环

  * 什么是事件循环机制
    * 

  * 为什么区分宏任务和微任务
    * 


  - 宏任务 微任务 执行时机

    - 为什么先执行微任务后执行宏任务

    - 其实是宏任务开始伴随着一次事件循环结束，而微任务在事件循环结束前执行的

  - settimeout 为什么不能整点返回
  - setInterval 有哪些缺点
    - clearTimeout 和 clearInterval 是否能互相清除对方的定时器

* 原型和原型链
  * 使用场景？

* 闭包
  * 内存泄漏怎么解决

* 执行上下文和作用域链
  * 执行上下文包含什么

* 正则

* 内存
  * 栈和堆

* 垃圾回收机制

* Js解析器中有哪些线程

* 网络请求
  * 原生 ajax 发请求
  * 如何取消请求
  * 什么时候可以取消请求

* 模块规范
  * esm cjs

* async 和 defer 区别

  * async 是脚本下载和dom解析并行执行，脚本下载完立即阻塞dom解析执行脚本
  * defer 是脚本下载和dom解析并行执行，脚本下载完会等待dom解析完再去执行脚本

* map 和 set
  * map 和 set 什么区别
  * map 和 object 什么区别

* proxy 和 reflect

## ts

- interface 和 type 区别
- 高级类型：交叉类型、联合类型
- 范型

## dom

- 获取、修改 div 的内容
- 事件代理优缺点
- 事件监听

## css

- BFC

- 清除浮动

- 行级元素和块级元素的区别

  display 属性值

- 选择器

  - 什么是伪元素
  - 优先级

- 布局

  - 布局方案有哪些
    - 圣杯布局和双飞翼布局

  - 父盒子宽高不固定，子盒子为正方形切始终为父盒子的一半
  - 三列布局，两边固定，中间可以伸缩
  - 两栏布局

- 防止冲突

  - scoped

- 渲染关键路径

  - 重排 重绘

- flex 布局

- - 过一遍mdn文档https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_flexible_box_layout/Basic_concepts_of_flexbox
  - 垂直居中

- position

  - 属性设置为不同的值之后会有哪些行为

- 图片如何垂直居中

- less sass

- rem em vw 单位

- 盒模型

  * 宽高由什么决定

  - 外边距重叠

- z-index

- margin 负值

- 颜色有哪几种表达方式

- 透明度

- 字体常用属性

- 1px问题

## html

* 语义化标签
  * aside header footer nav section
  * 好处：内容结构化，易读易维护；有利于 SEO
  

## Vue

- Vue2 和 vue3 区别
  - Vue3 多了哪些api
  - diff 算法的区别
  - 开发中能感知的到的
  - 生命周期函数
  - 单根节点 多根节点
  - 选项api 组合api
  - 异步组件
  - teleport
  - 响应式原理
  - diff 算法
  - 虚拟dom的区别
  - vue的getter为什么设置成一个函数，而不是一个对象

- 如何监听深层次对象
- $set 用法
- Vue 生命周期
  - 哪个阶段可以访问已经存在的真实dom

- watch 和 computed 的区别？
  - 应用场景
  - 缓存

- 双向绑定
  - Object.defineProperty，数据劫持，订阅发布
  - vue 改变数据的时候怎么变成前端的ui

- v-if 和 v-for
- watchEffect
- 虚拟dom 和 真实dom 的区别
- 双向绑定原理
- v-model 原理？
  - 语法糖

- keep-alive
- 组件间通信方式
  - 父子
  - 兄弟
  - event bus 实现方式

- v-for 的 key 作用
- 双向绑定原理
- pinia 和vuex区别
- vue-router 模式
- 模版编译原理 ast语法树
- nextTick
- seo

## webpack

- loader 和 plugin 区别
- tree shaking 原理
- 前端项目如何打包上线
- 提高构建速度

## 网络

- 浏览器发送url到渲染的整个过程
- 网址的组成部分
  - query 和 hash

- 进程和线程区别
  - 进程间通信方式

- 7层模型、5层模型、4层模型
- http
  - 请求有哪几种状态
  - 头部有哪些字段
    - content-type

  - ws
  - 状态码
    - 304 和缓存有关的状态码

  - http方法
    - get 和 post 区别
    - post 两次请求

  - https 安全机制
    - 对称加密和非对称加密
    - CA机构

  - http1.0 / 1.1 / 2.0
    - http 1.1 队头阻塞
    - http 2.0 多路复用原理
    - http 3 ？
    - 长链接 缓存处理
    - 传输格式

- tcp
  - tcp 和 udp 的区别
    - 为什么udp不安全

  - tcp 校验和的作用
  - 三次握手四次挥手
    - 为什么3次 4次
    - 四次挥手 4和2能不能合并

  - 粘包问题
  - 重传问题

- 浏览器缓存策略
  - 强缓存和协商缓存
  - 协商缓存的具体位置
  - 相关头部
  - 手动刷新与强制刷新，对缓存有什么影响

- 跨域
  - 跨域是怎么出现的
  - 同源策略
    - iframe 跨域通信
  - 解决方案
    - jsonp、nginx、webpack的代理、cors
    - 具体到实际用法

- cdn
  - 原理
  - 缺点
  
- 端口的作用

## 安全

- xss
- csrf

## 页面性能优化

- 如何测试性能
- 图片 预加载 懒加载

## 设计模式

- 知道哪些设计模式，使用场景
- 发布订阅模式
  - 风险有哪些


## git

- git pull 和git fetch
- 怎么使用 git 进行协同开发
- 回滚

## 算法

- 有序数组的合并
- topK
- 斐波那契数列两种实现方式
- 力扣221. 最大正方形
- hardman
- 大数相加
- 逆序数查找
- 找数组中第k大的数
- 最大岛屿面积
- 排序
  - 快排
  - 归并
  - 各种排序的复杂度

- 栈和队列
  - 两个栈模拟队列
  - 两个队列模拟栈

- 树
  - 求一颗树的高度
  - - 层序遍历
    - 递归
  - 最近公共父节点
  - LeetCode129题(求根节点到叶节点数字之和)
  - 层序输出
  - 中序后序构造二叉树

- 字符串
  - 最长回文子串
  - 最长不重复子串

- 链表
  - 奇偶有序输出
  - 判断链表是否相交话费

- 给定一个list，求list子数组中求和最大的值
- 找数组中出现的重复元素
- lru

* LeetCode1488

## 手撕前端

- 数组打平函数
  - 数组去重
  - 打平并去重
  
- 节流防抖
  - 立即执行
- 利用promise实现隔1秒输出1，输出1后，然后再隔2秒输出2.....直到再隔10秒输出10.
- 类数组对象转数组
- 手写 instanceof
- 求多个数组的交集
- js解析url
- 深拷贝
- 字符串字母去重，忽略大小写
- 手写原型继承

## 项目

- 账号登陆流程